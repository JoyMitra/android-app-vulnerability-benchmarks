# Summary
Apps that use the *call* method in the Content Provider API are vulnerable to exposing the underlying data store to unauthorized read and write.

# Versions of Android where the vulnerability is possible
Tested on Android 4.4 - Android 7.1

# Description of the vulnerability and the corresponding exploit
Android allows developers to share data across apps through the Content Provider API. Developers can limit access to their content
providers via permissions. Whenever a request for data read/write is made to a content provider method by a component, the android system checks to see if the component making the request has the required permissions to do so.

*Issue:* The Content provider API provides a method *call(String method, String args, Bundle extras)* to call any provider-defined method. The framework does
no permission checking on this entry into the content provider besides the basic ability for the application to get access to the provider at all.
For example, it has no idea whether the call being executed may read or write data in the provider, so can't enforce those individual permissions.
Any implementation of this method must do its own permission checks on incoming calls to make sure they are allowed.
Failure to do so will allow unauthorized components to interact with the content provider.

*Example:* This vulnerability is demonstrated by *Benign* and *Malicious*. *Benign* helps a user manage her files. This app has a content provider that provides an
interface to its Database. The Database saves all files created, edited and uploaded by the user. The app also works
offline i.e. when the device is not connected to the internet, it saves the files locally in its internal storage and
uploads the files to the database when the device is connected to the internet. Unfortunately the interface to save files
to local internal storage is vulnerable i.e. the *FileProvider.java* uses the method *call()* to save files locally in internal storage
when the device is offline. A malicious app can invoke it and inject malicious files into the internal file-
system (see *app/src/main/java/.../MainActivity.java*). When the device comes back online, the app data is sync-ed with the database.
Any malicious files in the internal file-system also gets uploaded. Since, the content provider in *Benign* allows other apps to read (but not write) from the database (see *app/src/main/AndroidManifest.xml*),
a *Malicious* can read the injected files from the database and execute it in its own context.

# Steps to build the sample apps and to exploit the vulnerability

1. List targets:

    `$ android list targets`

2. List available Android Virtual Devices:

    `$ android list avd`

3. Create an emulator:

    `$ android create avd -n <name> -t <target>`

    *<target>* is obtained from the command listed in 1. *<name>* is the name you choose to give to the avd.

4. Start emulator:

    `$ emulator -avd <avd_name>`

    *<avd-name>* is obtained from the command listed in 2.

5. Build and install *Benign*:

    `$ cd Benign`

    Make sure there is a file called local.properties with an entry sdk=/path/to/Android/sdk.

    `$ ./gradlew installDebug`

6. Build and install *Malicious*:

    `$ cd Malicious`

    Make sure there is a file called local.properties with an entry sdk=/path/to/Android/sdk.

    `$ ./gradlew installDebug`

7.  Launch *Malicious* and click on "Inject File"

8.  You can verify if the file has been injected by running adb:

     `$ <path-to-android-sdk>/platform-tools/adb shell run-as "edu.ksu.cs.benign"`

     `$ ls files`

    You should be able to see a file called "MalFile.sh"

# References

1.  [Official Android Documentation](https://developer.android.com/reference/android/content/ContentProvider.html#call(java.lang.String, java.lang.String, android.os.Bundle))
